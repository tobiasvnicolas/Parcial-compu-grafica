<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Preguntados - Parcial de Organizaci√≥n</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap');

        :root {
            --primary-color: #3498db;
            --secondary-color: #2c3e50;
            --correct-color: #2ecc71;
            --incorrect-color: #e74c3c;
            --neutral-bg: #ecf0f1;
            --white: #ffffff;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background-color: var(--secondary-color);
            color: var(--secondary-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }

        .quiz-container {
            background: var(--white);
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            width: 100%;
            max-width: 600px;
            overflow: hidden;
            text-align: center;
        }

        .header {
            background-color: var(--primary-color);
            color: var(--white);
            padding: 20px;
        }

        .header h1 {
            margin: 0;
            font-size: 1.5em;
        }

        .stats {
            display: flex;
            justify-content: space-between;
            font-weight: 600;
            margin-top: 10px;
        }

        .main-content {
            padding: 30px;
        }

        #question-text {
            font-size: 1.2em;
            font-weight: 600;
            margin-bottom: 25px;
            min-height: 50px;
        }

        .answer-options {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }

        .btn {
            background-color: var(--neutral-bg);
            border: 2px solid transparent;
            border-radius: 10px;
            padding: 15px;
            font-size: 1em;
            cursor: pointer;
            text-align: left;
            transition: all 0.3s ease;
        }
        
        .btn:hover:not([disabled]) {
            background-color: #dbe4e8;
            border-color: var(--primary-color);
        }
        
        .btn:disabled {
            cursor: not-allowed;
        }

        .btn.correct {
            background-color: var(--correct-color);
            color: var(--white);
            font-weight: bold;
        }

        .btn.incorrect {
            background-color: var(--incorrect-color);
            color: var(--white);
            font-weight: bold;
        }

        #next-btn {
            display: none; /* Oculto por defecto */
            width: 50%;
            margin: 30px auto 0;
            padding: 15px;
            background-color: var(--primary-color);
            color: var(--white);
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #next-btn:hover {
            background-color: #2980b9;
        }
        
        #results-container {
            padding: 40px;
        }
        
        #results-container h2 {
            margin-top: 0;
        }

        #play-again-btn {
             width: 50%;
            margin: 30px auto 0;
            padding: 15px;
            background-color: var(--correct-color);
            color: var(--white);
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s;
        }


    </style>
</head>
<body>

    <div class="quiz-container">
        <div class="header">
            <h1>Desaf√≠o de Computaci√≥n Gr√°fica üèÜ</h1>
            <div class="stats">
                <span id="question-counter"></span>
                <span id="score">Puntaje: 0</span>
            </div>
        </div>
        
        <div class="main-content" id="quiz-area">
            <p id="question-text">Aqu√≠ va la pregunta...</p>
            <div class="answer-options" id="answer-buttons">
                </div>
            <button id="next-btn">Siguiente Pregunta ‚Üí</button>
        </div>

        <div class="main-content" id="results-container" style="display: none;">
            <h2>¬°Juego Terminado!</h2>
            <p id="results-text">Obtuviste X de Y respuestas correctas.</p>
            <button id="play-again-btn">Volver a Jugar</button>
        </div>
    </div>

    <script>
        const questions = [
            // Bloque 1: General de Computaci√≥n Gr√°fica:
            {
              question: '¬øQu√© modelo de color utilizamos en nuestro proyecto? ¬øPor qu√©?',
              answers: [
                { text: 'Utilizamos el modelo CMYK porque es el est√°ndar de impresi√≥n y reproduce mejor los colores met√°licos.', correct: false },
                { text: 'Utilizamos el modelo HSV porque facilita la selecci√≥n de tonos y saturaci√≥n en interfaces gr√°ficas.', correct: false },
                { text: 'Utilizamos el modelo RGB (Red, Green, Blue) con canal alfa (RGBA), porque las pantallas emiten luz mediante p√≠xeles que mezclan estos tres colores primarios aditivos.', correct: true },
                { text: 'Utilizamos el modelo YCbCr porque permite mayor compresi√≥n en los gr√°ficos digitales.', correct: false }
              ]
            },
            {
              question: '¬øQu√© primitivas gr√°ficas utilizamos en nuestro proyecto?',
              answers: [
                { text: 'Utilizamos cuadrados y rect√°ngulos para simplificar la representaci√≥n de pol√≠gonos.', correct: false },
                { text: 'Utilizamos tri√°ngulos. Con ellos construimos figuras m√°s complejas como el Quad y el Cube.', correct: true },
                { text: 'Utilizamos l√≠neas y puntos, ya que son las primitivas m√°s simples en OpenGL.', correct: false },
                { text: 'Utilizamos pol√≠gonos de 5 lados para obtener mejor suavizado en los bordes.', correct: false }
              ]
            },
            {
              question: '¬øPara qu√© se suele utilizar la operaci√≥n entre vectores: Producto Escalar? ¬øQu√© tipo de dato devuelve?',
              answers: [
                { text: 'Se utiliza para obtener un vector perpendicular a los dos vectores dados. Devuelve un vector 3D (vec3).', correct: false },
                { text: 'Se utiliza para calcular el √°ngulo entre dos vectores o la proyecci√≥n de un vector sobre otro. Devuelve un valor escalar (float).', correct: true },
                { text: 'Se utiliza para calcular el m√≥dulo de un vector a partir de su direcci√≥n. Devuelve un n√∫mero entero (int).', correct: false },
                { text: 'Se utiliza para combinar dos vectores en uno de mayor dimensi√≥n. Devuelve un vector 4D (vec4).', correct: false }
              ]
            },
            {
              question: '¬øPara qu√© se suele utilizar la operaci√≥n entre vectores: Producto Vectorial? ¬øQu√© tipo de dato devuelve?',
              answers: [
                { text: 'Se utiliza para calcular el √°ngulo entre dos vectores. Devuelve un escalar (float).', correct: false },
                { text: 'Se utiliza para crear un vector perpendicular a los dos vectores dados. Devuelve un vector con las mismas dimensiones que los originales.', correct: true },
                { text: 'Se utiliza para obtener la magnitud combinada de dos vectores. Devuelve un n√∫mero entero (int).', correct: false },
                { text: 'Se utiliza para normalizar un vector perpendicular a los dos vectores dados. Devuelve un vector unitario que fue normalizado mediante la librer√≠a gml.', correct: false }
              ]
            },
            {
              question: '¬øCu√°l es la coordenada homog√©nea w para un punto? ¬øPor qu√©?',
              answers: [
                { text: 'La coordenada w es 0 porque los puntos no deben verse afectados por traslaciones.', correct: false },
                { text: 'La coordenada w es 1 porque los puntos deben verse afectados por las traslaciones.', correct: true },
                { text: 'La coordenada w es 2 porque representa la magnitud del punto en el espacio.', correct: false },
                { text: 'La coordenada w es -1 porque las traslaciones invierten su direcci√≥n.', correct: false }
              ]
            },
            {
              question: '¬øCu√°l es la coordenada homog√©nea w para una direcci√≥n? ¬øPor qu√©?',
              answers: [
                { text: 'La coordenada w es 1 porque las direcciones deben desplazarse junto con los puntos.', correct: false },
                { text: 'La coordenada w es 0 porque las direcciones no deben verse afectadas por traslaciones.', correct: true },
                { text: 'La coordenada w es -1 porque representan una inversi√≥n del eje.', correct: false },
                { text: 'La coordenada w es 2 porque define la longitud de la direcci√≥n.', correct: false }
              ]
            },
            {
              question: '¬øQu√© estructura matem√°tica me permite pasar un vector de un espacio vectorial a otro?',
              answers: [
                { text: 'Un escalar que amplifica o reduce las componentes del vector, generalmente ayuda a cambiar el vector de un tama√±o del plano a otro.', correct: false },
                { text: 'Una matriz de transformaci√≥n, generalmente de 4x4 en 3D, para cambiar de un sistema de coordenadas a otro.', correct: true },
                { text: 'Un tensor que aplica una rotaci√≥n no lineal sobre el vector.', correct: false },
                { text: 'Una funci√≥n trigonom√©trica que define el √°ngulo del nuevo espacio.', correct: false }
              ]
            },
            {
              question: '¬øQu√© dimensiones debe tener una matriz para aplicar transformaciones lineales en 3D?',
              answers: [
                { text: 'Debe ser una matriz de 3x3, porque el espacio tiene tres ejes.', correct: false },
                { text: 'Debe ser una matriz de 4x4 para trabajar con coordenadas homog√©neas en 3D.', correct: true },
                { text: 'Debe ser una matriz de 2x2 para mantener la eficiencia computacional.', correct: false },
                { text: 'Debe ser una matriz de 5x5 para incluir la componente temporal.', correct: false }
              ]
            },
            {
              question: '¬øQu√© funci√≥n cumple, en Computaci√≥n Gr√°fica, la inversa de una matriz? Dame un ejemplo.',
              answers: [
                { text: 'La inversa amplifica las transformaciones aplicadas a los objetos. Por ejemplo, duplicar la escala necesaria para poder llega a tener el tama√±o de la ventana.', correct: false },
                { text: 'La inversa de una matriz deshace o invierte las transformaciones aplicadas. Por ejemplo, transformar un rayo del espacio de la c√°mara al del mundo.', correct: true },
                { text: 'La inversa sirve para interpolar entre dos transformaciones. Por ejemplo, calcular un promedio necesario para calcular el Raycasting.', correct: false },
                { text: 'La inversa elimina las rotaciones pero conserva las escalas.', correct: false }
              ]
            },
            {
              question: '¬øA qu√© hace referencia el "Espacio del Objeto"?',
              answers: [
                { text: 'Al sistema de coordenadas global del mundo 3D, despu√©s de aplicarle transformaciones.', correct: false },
                { text: 'Al sistema de coordenadas local del objeto, antes de aplicarle transformaciones.', correct: true },
                { text: 'Al espacio donde se proyectan los p√≠xeles en pantalla.', correct: false },
                { text: 'Al conjunto de v√©rtices normalizados despu√©s del pipeline gr√°fico.', correct: false }
              ]
            },
            {
              question: '¬øA qu√© hace referencia el "Espacio del Mundo"?',
              answers: [
                { text: 'Es el sistema de coordenadas local del objeto, antes de aplicar transformaciones.', correct: false },
                { text: 'Es el sistema de coordenadas global de la escena, donde todos los objetos se posicionan y el origen (0,0,0) sirve como referencia com√∫n.', correct: true },
                { text: 'Es el espacio 2D en el que se renderiza la escena en pantalla.', correct: false },
                { text: 'Es el sistema de coordenadas relativo a la c√°mara.', correct: false }
              ]
            },
            {
              question: '¬øA qu√© hace referencia el "Espacio de Vista"?',
              answers: [
                { text: 'Es el sistema de coordenadas global donde todos los objetos comparten el mismo origen.', correct: false },
                { text: 'Es el sistema de coordenadas relativo a la c√°mara, donde el origen est√° en la posici√≥n de la c√°mara y los ejes se orientan seg√∫n hacia d√≥nde mira.', correct: true },
                { text: 'Es el sistema utilizado por la GPU para proyectar los p√≠xeles en pantalla.', correct: false },
                { text: 'Es el espacio donde se aplican las transformaciones de textura (UV).', correct: false }
              ]
            },
            {
              question: '¬øD√≥nde est√° el punto de origen, normalmente, en una pantalla?',
              answers: [
                { text: 'Siempre est√° en el centro de la pantalla, independientemente del sistema.', correct: false },
                { text: 'Depende del sistema: en algunos est√° en la esquina superior izquierda (interfaces gr√°ficas) y en otros en la inferior izquierda (OpenGL).', correct: true },
                { text: 'Siempre est√° en la esquina inferior derecha, porque es el punto con coordenadas m√°ximas. Adem√°s existe una convenci√≥n internacional, que facilita el desarrollo de la computaci√≥n gr√°fica mundial', correct: false },
                { text: 'Se define en funci√≥n de la posici√≥n de la c√°mara en la escena. C√≥mo esta puede variar entonces es relativo y depende de la c√°mara', correct: false }
              ]
            },
            {
              question: '¬øD√≥nde est√° el punto de origen, normalmente, en un objeto de la escena?',
              answers: [
                { text: 'En la esquina inferior del objeto, donde comienza la malla 3D.', correct: false },
                { text: 'En el centro geom√©trico del objeto, tambi√©n llamado pivot point.', correct: true },
                { text: 'En la posici√≥n global (0,0,0) de la escena.', correct: false },
                { text: 'En el v√©rtice con coordenadas m√°s bajas (m√≠nimos valores x, y, z).', correct: false }
              ]
            },
            {
              question: '¬øQu√© son coordenadas normalizadas NDC?',
              answers: [
                { text: 'Son coordenadas que van de 0 a 1 en todos los ejes (x, y, z) y se usan para mapear texturas en los objetos.', correct: false },
                { text: 'Son coordenadas que van de -1 a 1 en todos los ejes (x, y, z) y se usan tras la proyecci√≥n para estandarizar la escena.', correct: true },
                { text: 'Son coordenadas de p√≠xeles en todos los ejes (x, y, z), que se calculan despu√©s del rasterizado.', correct: false },
                { text: 'Son coordenadas locales del modelo en todos los ejes (x, y, z), que a√∫n no fueron transformadas.', correct: false }
              ]
            },
            {
              question: '¬øCu√°l es la principal diferencia entre la proyecci√≥n en perspectiva y la ortogr√°fica?',
              answers: [
                { text: 'La proyecci√≥n perspectiva mantiene el tama√±o constante y la ortogr√°fica reduce los objetos lejanos.', correct: false },
                { text: 'La proyecci√≥n perspectiva simula la visi√≥n real (objetos lejanos se ven m√°s peque√±os) y la ortogr√°fica mantiene el tama√±o sin importar la distancia.', correct: true },
                { text: 'La proyecci√≥n ortogr√°fica aplica efectos de desenfoque seg√∫n la distancia.', correct: false },
                { text: 'La proyecci√≥n perspectiva utiliza coordenadas normalizadas, mientras que la ortogr√°fica no.', correct: false }
              ]
            },
            {
              question: '¬øQu√© son el VBO, IBO y VAO? Describe brevemente la funci√≥n de cada uno.',
              answers: [
                { text: 'Son estructuras que conectan los datos del modelo con el shader: VBO almacena v√©rtices, IBO √≠ndices, y VAO describe c√≥mo se vinculan.', correct: true },
                { text: 'Son librer√≠as de OpenGL que permiten importar modelos 3D externos al motor.', correct: false },
                { text: 'Son funciones matem√°ticas que definen la orientaci√≥n del modelo en el espacio.', correct: false },
                { text: 'Son shaders espec√≠ficos para controlar v√©rtices, iluminaci√≥n y texturas.', correct: false }
              ]
            },
            {
              question: '¬øQu√© indica la normal de un v√©rtice?',
              answers: [
                { text: 'Indica la posici√≥n global del v√©rtice dentro del modelo.', correct: false },
                { text: 'Indica la direcci√≥n perpendicular a la superficie en ese v√©rtice, es decir, hacia d√≥nde mira.', correct: true },
                { text: 'Indica la cantidad de luz que incide en el v√©rtice, es decir, la intensidad lum√≠nica.', correct: false },
                { text: 'Indica la magnitud de la velocidad de animaci√≥n del v√©rtice.', correct: false }
              ]
            },
            {
              question: '¬øEn qu√© lenguaje programamos para hacer un shader con OpenGL?',
              answers: [
                { text: 'En C++.', correct: false },
                { text: 'En GLSL.', correct: true },
                { text: 'En Python.', correct: false },
                { text: 'En Vertex.', correct: false }
              ]
            },
            {
              question: '¬øQu√© tipo de unidades recorre el Vertex Shader?',
              answers: [
                { text: 'El Vertex Shader recorre figuras geom√©tricas. Por ejemplo: pol√≠gonos completos.', correct: false },
                { text: 'El Vertex Shader recorre p√≠xeles, ejecut√°ndose una vez por cada fragmento.', correct: false },
                { text: 'El Vertex Shader recorre v√©rtices, ejecut√°ndose una vez por cada v√©rtice del modelo.', correct: true },
                { text: 'El Vertex Shader recorre tri√°ngulos, ejecut√°ndose una vez por cada primitiva (y esto lo hace m√°s eficiente).', correct: false }
              ]
            },
            {
              question: '¬øQu√© tipo de unidades recorre el Fragment Shader?',
              answers: [
                { text: 'El Fragment Shader recorre tri√°ngulos (de esta forma puede construir cualquier figura) enteros de la geometr√≠a rasterizada, procesando cada v√©rtice de forma individual.', correct: false },
                { text: 'El Fragment Shader recorre fragmentos (p√≠xeles del modelo rasterizado). Se ejecuta una vez por cada p√≠xel que forma parte de la geometr√≠a rasterizada.', correct: true },
                { text: 'El Fragment Shader recorre v√©rtices transformados despu√©s del Vertex Shader, aplicando iluminaci√≥n b√°sica.', correct: false },
                { text: 'El Fragment Shader recorre grupos de pol√≠gonos proyectados en pantalla, ejecut√°ndose una vez por cada pol√≠gono.', correct: false }
              ]
            },
            {
              question: 'En el Render Pipeline de la GPU ¬øQu√© se ejecuta primero, el Vertex o el Fragment shader?',
              answers: [
                { text: 'Primero se ejecuta el Fragment Shader, luego el Vertex Shader y finalmente la rasterizaci√≥n de la escena completa.', correct: false },
                { text: 'En el Render Pipeline primero se ejecuta el Vertex Shader (transforma cada v√©rtice), luego ocurre la rasterizaci√≥n, y finalmente se ejecuta el Fragment Shader (calcula el color de cada p√≠xel).', correct: true },
                { text: 'El orden depende de la complejidad del modelo: en algunos casos el Fragment Shader puede ejecutarse antes para optimizar el proceso.', correct: false },
                { text: 'Los dos shaders se ejecutan al mismo tiempo de forma paralela, sin un orden definido dentro del pipeline.', correct: false }
              ]
            },
            {
              question: '¬øEl Compute Shader recorre unidades?',
              answers: [
                { text: 'S√≠, recorre v√©rtices y p√≠xeles igual que los dem√°s shaders, pero lo hace con mayor velocidad de c√°lculo. Adem√°s de esto se ejectuta en grupos de trabajo (work groups) de forma paralela.', correct: false },
                { text: 'El Compute Shader no recorre unidades de geometr√≠a como los otros shaders. Se ejecuta en grupos de trabajo (work groups) de forma paralela, procesando datos sin depender del Render Pipeline.', correct: true },
                { text: 'Recorre pol√≠gonos y caras de los objetos tridimensionales, procesando sus normales en paralelo. Esto permite que el compute shader s√≥lo trabaje en una s√≥la etapa del Render Pipeline.', correct: false },
                { text: 'Solo recorre los fragmentos visibles en pantalla para acelerar el c√°lculo de iluminaci√≥n.', correct: false }
              ]
            },
            {
              question: '¬øEl Compute Shader se ejecuta en GPU o en CPU?',
              answers: [
                { text: 'El Compute Shader se ejecuta en la CPU, ya que realiza tareas de control y no de renderizado.', correct: false },
                { text: 'El Compute Shader se ejecuta en la GPU.', correct: true },
                { text: 'El Compute Shader puede ejecutarse en cualquiera de las dos, dependiendo del tipo de compilaci√≥n.', correct: false },
                { text: 'El Compute Shader se ejecuta en un hilo separado del sistema operativo para controlar la memoria gr√°fica.', correct: false }
              ]
            },
            {
              question: '¬øCu√°l es la diferencia entre trabajar con Vertex y Fragment shader o hacerlo con Compute shader?',
              answers: [
                { text: 'El Vertex y Fragment shader se usan para procesar animaciones, mientras que el Compute shader se usa para controlar el movimiento de la c√°mara.', correct: false },
                { text: 'El Vertex-Fragment shader est√° atado al Render Pipeline: el Vertex procesa v√©rtices y el Fragment procesa p√≠xeles rasterizados. El Compute Shader es de prop√≥sito general, independiente del pipeline y puede procesar toda la escena simult√°neamente (ideal para raytracing).', correct: true },
                { text: 'El Compute shader reemplaza completamente a los Vertex y Fragment shaders, ya que puede renderizar la geometr√≠a y aplicar colores directamente, independiente del pipeline. Sin embargo esto no garantiza que pueda procesar toda la escena simult√°neamente', correct: false },
                { text: 'El Vertex y Fragment shader trabajan en CPU y el Compute shader en GPU, lo que los hace incompatibles entre s√≠. Por estas razones el Raycasting se hace en CPU', correct: false }
              ]
            },
            {
              question: '¬øQu√© es un work group?',
              answers: [
                { text: 'Un work group es un conjunto de v√©rtices agrupados en el Vertex Shader para optimizar la geometr√≠a de la escena. Permiten dividir el trabajo total en bloques que se procesan simult√°neamente en la GPU.', correct: false },
                { text: 'Work Group es un grupo de hilos de ejecuci√≥n en un Compute Shader que trabajan en paralelo. Permiten dividir el trabajo total en bloques que se procesan simult√°neamente en la GPU.', correct: true },
                { text: 'Un work group es una colecci√≥n de texturas aplicadas a un mismo objeto para mejorar la resoluci√≥n visual. Permiten dividir el trabajo total en bloques que se procesan simult√°neamente en la GPU.', correct: false },
                { text: 'Un work group es una lista de shaders que se ejecutan en orden para procesar un modelo 3D. Permiten dividir el trabajo total en bloques que se procesan simult√°neamente en la GPU.', correct: false }
              ]
            },
            {
              question: '¬øQu√© son los Uniforms? ¬øEn qu√© se diferencian con los atributos de un v√©rtice?',
              answers: [
                { text: 'Los uniforms son variables que cambian por v√©rtice, mientras que los atributos son constantes para todos los shaders.', correct: false },
                { text: 'Los uniforms son variables globales enviadas desde la CPU con el mismo valor para todos los v√©rtices y fragmentos, mientras que los atributos que var√≠an entre v√©rtices.', correct: true },
                { text: 'Los uniforms se definen dentro del shader y se actualizan autom√°ticamente en cada frame, sin intervenci√≥n de la CPU. Sin embargo aunque no intervenga la CPU puede ser que si lo haga la GPU', correct: false },
                { text: 'Los uniforms almacenan texturas 3D y los atributos contienen datos de color e iluminaci√≥n.', correct: false }
              ]
            },
            {
              question: '¬øQu√© son los Sampler2D?',
              answers: [
                { text: 'Es una variable local que guarda un vector tridimensional usado para calcular sombras. Permite leer colores de una imagen cargada en la GPU usando coordenadas UV.', correct: false },
                { text: 'Es un tipo de uniform especial que representa una textura 2D. Permite leer colores de una imagen cargada en la GPU usando coordenadas UV.', correct: true },
                { text: 'Es una estructura que almacena los v√©rtices de una textura y los interpola en tiempo real. Permite leer colores de una imagen cargada en la GPU usando coordenadas UV.', correct: false },
                { text: 'Es un objeto de memoria que contiene las posiciones de los p√≠xeles dentro de una textura. Permite leer colores de una imagen cargada en la GPU usando coordenadas UV.', correct: false }
              ]
            },
            {
              question: '¬øQu√© es un Ray (rayo) en Computaci√≥n Gr√°fica?',
              answers: [
                { text: 'Es un vector cerrado que define una trayectoria finita usada para modelar curvas o trayectorias de movimiento. Principalmente cubos y planos', correct: false },
                { text: 'El rayo en Computaci√≥n Gr√°fica es una semirrecta definida por un punto de origen y una direcci√≥n. Se usa para simular trayectorias de luz o c√°lculos de colisiones.', correct: true },
                { text: 'Es una l√≠nea infinita que conecta dos puntos del espacio tridimensional para definir superficies planas. Adem√°s es muy √∫til para definir posiciones de la c√°mara', correct: false },
                { text: 'Es una estructura matem√°tica usada para interpolar colores entre dos v√©rtices de un tri√°ngulo.', correct: false }
              ]
            },

            // Bloque 2: Proyecto:
            {
              question: "¬øD√≥nde encontramos matrices de transformaci√≥n en nuestro proyecto?",
              answers: [
                { text: "Cada vez que creamos o utilizamos el espacio vectorial de un objeto de la escena. Por ejemplo: En las clases Cube o Quad en el m√©todo get_model_matrix En la clase Camera en el m√©todo get_view_matrix y get_projection_matrix.", correct: true },
                { text: "Cuando importamos un modelo 3D desde Blender y lo posicionamos directamente en la escena sin aplicar shaders ni c√°maras adicionales. Adem√°s utilizan los m√©todos get_view_matrix y get_projection_matrix", correct: false },
                { text: "Solamente cuando definimos las luces principales y sus intensidades para calcular reflejos y sombras dentro de la escena. Posterior a ello usamos los m√©todos get_view_matrix y get_projection_matrix", correct: false },
                { text: "En los archivos de configuraci√≥n JSON donde definimos los materiales, las texturas y las posiciones iniciales de los objetos.", correct: false }
              ]
            },
            {
              question: "¬øDesde d√≥nde se trazan los Rays en nuestro proyecto?",
              answers: [
                { text: "En nuestro proyecto, los Rays se trazan desde la posici√≥n de la c√°mara hacia cada p√≠xel de la pantalla (en el caso del raytracing). En raycasting tambi√©n desde la c√°mara, pero hacia la posici√≥n del mouse.", correct: true },
                { text: "Los Rays se trazan desde el centro de la escena hacia cada objeto visible, siguiendo la direcci√≥n de sus normales.", correct: false },
                { text: "Se lanzan desde la posici√≥n de cada v√©rtice del modelo hacia la c√°mara para calcular el color de iluminaci√≥n.", correct: false },
                { text: "Los Rays se calculan desde el punto medio del terreno y se expanden hacia los bordes del mapa en direcciones aleatorias.", correct: false }
              ]
            },
            {
              question: "¬øQu√© funci√≥n cumple la clase HitBox?",
              answers: [
                { text: "La clase HitBox detecta si un rayo colisiona con el objeto. Es un volumen simplificado (caja) que envuelve al objeto para hacer los c√°lculos de colisi√≥n m√°s eficientes.", correct: true },
                { text: "La clase HitBox determina el color promedio de una textura para aplicar sombreado b√°sico en la superficie del objeto.", correct: false },
                { text: "HitBox almacena los v√©rtices y las normales del objeto para crear una versi√≥n de baja resoluci√≥n del mismo.", correct: false },
                { text: "Se encarga de proyectar los rayos de luz sobre el modelo para determinar el brillo especular de cada cara.", correct: false }
              ]
            },
            {
              question: "¬øCu√°ntos Rays se necesitan para calcular si el mouse est√° sobre un objeto en pantalla?",
              answers: [
                { text: "Para calcular si el mouse est√° sobre un objeto de pantalla, trazamos un solo Ray. Se lanza un rayo desde la c√°mara en direcci√≥n a la posici√≥n del cursor en la escena 3D.", correct: true },
                { text: "Se necesitan tres Rays, uno por cada eje del espacio tridimensional, para verificar la colisi√≥n en todas las direcciones posibles. Aunque esto depende ya que si s√≥lo estamos trabajando en 2D s√≥lo necesitar√≠amos configurar la ventana para usar solamente 2 Rays.", correct: false },
                { text: "Se lanzan m√∫ltiples Rays en forma de cuadr√≠cula alrededor del cursor para obtener una detecci√≥n m√°s precisa del √°rea seleccionada.", correct: false },
                { text: "El c√°lculo se realiza con dos Rays opuestos que permiten estimar la profundidad y posici√≥n del objeto bajo el cursor.", correct: false }
              ]
            },
            {
              question: "¬øPara qu√© fin utilizamos Pyglet?",
              answers: [
                { text: "Usamos Pyglet para crear la ventana de la aplicaci√≥n, gestionar el ciclo de renderizado (el loop principal) y capturar eventos de entrada como el mouse.", correct: true },
                { text: "Pyglet se usa √∫nicamente para calcular las colisiones (usando el HitBox y HitBoxOBB) entre los objetos dentro de la escena 3D de manera m√°s r√°pida.", correct: false },
                { text: "Lo utilizamos para definir las c√°maras, los materiales y los shaders de todos los objetos (el cube y el Quad) en el proyecto.", correct: false },
                { text: "Pyglet sirve como librer√≠a matem√°tica para calcular transformaciones lineales y multiplicaciones de matrices.", correct: false }
              ]
            },
            {
              question: "¬øPara qu√© fin utilizamos ModernGL?",
              answers: [
                { text: "Usamos ModernGL para simplificar el uso de OpenGL moderno. Es una wrapper de Python que hace m√°s f√°cil trabajar con shaders, buffers y texturas.", correct: true },
                { text: "ModernGL se utiliza para renderizar im√°genes en 2D usando un motor f√≠sico de part√≠culas basado en CPU. Sin embargo esto era al inicio dado que con el avance de la tecnolog√≠a empez√≥ a estar basado en la GPU", correct: false },
                { text: "Lo usamos para crear animaciones avanzadas y efectos de sonido sincronizados con los shaders.", correct: false },
                { text: "ModernGL es una herramienta que permite generar geometr√≠as fractales sin necesidad de utilizar buffers manuales.", correct: false }
              ]
            },
            {
              question: "¬øQu√© atributos tiene un Model en nuestro proyecto?",
              answers: [
                { text: "Los atributos que tiene la clase Model en nuestro proyecto son: vertices (posiciones), indices, colors (colores), normals (normales) y texcoords (coordenadas UV).", correct: true },
                { text: "Cada Model contiene los par√°metros de iluminaci√≥n, los tipos de textura, los efectos de postprocesado y la c√°mara activa.", correct: false },
                { text: "Los Model almacenan las rutas de los shaders, los buffers de sonido y las referencias a los controladores de entrada.", correct: false },
                { text: "Un Model guarda las transformaciones de rotaci√≥n, escala y los valores de brillo aplicados por frame.", correct: false }
              ]
            },
            {
              question: "¬øQu√© ventaja ofrece separar los atributos de v√©rtices (posiciones, colores, normales) en lugar de tener un √∫nico array?",
              answers: [
                { text: "Separar los atributos de los v√©rtices permite mayor flexibilidad: podemos tener modelos que solo definen algunos atributos (por ejemplo, solo posici√≥n y normales sin colores). Tambi√©n hace el c√≥digo m√°s legible y permite que el shader consuma solo los atributos que necesita, optimizando la memoria.", correct: true },
                { text: "Porque de esa forma se pueden ordenar m√°s f√°cilmente los objetos dentro del archivo de configuraci√≥n del motor de render (por ejemplo, solo posici√≥n y normales sin colores). Tambi√©n hace el c√≥digo m√°s legible y permite que el shader consuma solo los atributos que necesita, optimizando la memoria.", correct: false },
                { text: "Para reducir la cantidad de llamadas al shader y combinar m√∫ltiples objetos en una sola textura global. Tambi√©n hace el c√≥digo m√°s legible y permite que el shader consuma solo los atributos que necesita, optimizando la memoria.", correct: false },
                { text: "Porque as√≠ los v√©rtices pueden almacenarse en archivos comprimidos y cargarse de forma as√≠ncrona en la GPU. Tambi√©n hace el c√≥digo m√°s legible y permite que el shader consuma solo los atributos que necesita, optimizando la memoria.", correct: false }
              ]
            },
            {
              question: "¬øQu√© suceder√≠a si los nombres de los atributos en la clase VertexLayout no coinciden con los del shader?",
              answers: [
                { text: "Si los nombres de los atributos en la clase VertexLayout no coinciden con los del shader, √©ste no recibir√≠a los datos esperados. El atributo quedar√≠a sin vincular y el shader usar√≠a valores por defecto o basura, causando errores visuales o de ejecuci√≥n.", correct: true },
                { text: "El shader intentar√≠a renombrar autom√°ticamente las variables para ajustarse a la estructura recibida desde el CPU.", correct: false },
                { text: "No pasar√≠a nada, ya que ModernGL se encarga de reasignar los valores en tiempo de ejecuci√≥n sin errores.", correct: false },
                { text: "El motor asignar√≠a los atributos por posici√≥n en lugar de por nombre, corrigiendo autom√°ticamente el problema.", correct: false }
              ]
            },
            {
              question: "¬øC√≥mo le pasamos los atributos del Model al Vertex Shader?",
              answers: [
                { text: "Los atributos del Model los pasamos al Vertex Shader a trav√©s de VBOs (que contienen los datos) organizados en un VAO (que describe c√≥mo leerlos). En nuestro proyecto, la clase Graphics se encarga de crear estos buffers y vincularlos con el shader.", correct: true },
                { text: "Los atributos se env√≠an mediante archivos temporales en formato binario que se cargan directamente en la GPU.", correct: false },
                { text: "Usamos variables globales en Python para compartir los datos del modelo directamente con el shader sin buffers.", correct: false },
                { text: "Los atributos se escriben dentro del mismo c√≥digo GLSL al inicio del Vertex Shader para evitar dependencias externas.", correct: false }
              ]
            },
            {
              question: "¬øQu√© responsabilidad tiene la clase Material?",
              answers: [
                { text: "Relacionar un shader con diferentes texturas.", correct: true },
                { text: "Almacenar los v√©rtices, √≠ndices y normales de un modelo para optimizar su renderizado.", correct: false },
                { text: "Gestionar la c√°mara principal del proyecto y las luces que afectan la escena.", correct: false },
                { text: "Encargarse de la creaci√≥n de buffers y del env√≠o de datos entre la CPU y la GPU.", correct: false }
              ]
            },
            {
              question: "¬øQu√© almacena la clase Texture y qu√© m√©todo utiliza para convertir los datos a un formato que OpenGL pueda usar?",
              answers: [
                { text: "La clase Texture almacena un ImageData (matriz de numpy con los colores de cada p√≠xel). Usa el m√©todo get_bytes() para convertir esa matriz en bytes que OpenGL puede cargar en la GPU.", correct: true },
                { text: "Texture almacena las normales y posiciones de los v√©rtices, y usa el m√©todo normalize() para pasarlos al shader.", correct: false },
                { text: "Guarda la configuraci√≥n de los materiales y aplica el m√©todo compile_texture() para integrarlos en el VAO.", correct: false },
                { text: "Contiene la informaci√≥n del color promedio de la escena y utiliza el m√©todo convert_to_rgb() para codificarla.", correct: false }
              ]
            },
            {
              question: "¬øPor qu√© es importante que los nombres de las texturas (Texture.name) coincidan con los uniforms del Fragment shader?",
              answers: [
                { text: "Es importante que los nombres de las texturas (Texture.name) coincidan con los uniforms de nuestro shader para que el shader pueda referenciar correctamente la textura. El nombre act√∫a como identificador que conecta la textura cargada con el uniform sampler2D declarado en el shader.", correct: true },
                { text: "Porque si no coinciden, OpenGL renombrar√° autom√°ticamente las variables internas generando un sobreuso de memoria.", correct: false },
                { text: "Para que ModernGL pueda crear los buffers de profundidad antes de enviar la textura al pipeline gr√°fico.", correct: false },
                { text: "Porque los uniforms deben tener la misma longitud de nombre que las texturas para evitar conflictos de compilaci√≥n.", correct: false }
              ]
            },
            {
              question: "¬øC√≥mo le cambio el color a un cubo?",
              answers: [
                { text: "Para cambiarle el color a un cubo. Creo o Modifico una Texture con el color deseado, creo, si no existe, un Material que vincule esa textura con un shader, y asigno ese material al cubo cuando lo agrego a la escena.", correct: true },
                { text: "Basta con modificar el nombre del objeto en el c√≥digo y OpenGL aplicar√° un color aleatorio autom√°ticamente.", correct: false },
                { text: "Se debe actualizar el VAO del cubo con un nuevo set de v√©rtices que representen los tonos deseados.", correct: false },
                { text: "Hay que cambiar la posici√≥n del cubo en el espacio para que adopte un color diferente del entorno.", correct: false }
              ]
            },
            {
              question: "¬øC√≥mo hago que uno de los cubos se deje de animar?",
              answers: [
                { text: "Para que uno de los cubos se deje de animar, al crear la instancia del Cube, le paso el par√°metro animated=False.", correct: true },
                { text: "Modifico la textura del cubo y cambio su canal alfa a cero para detener el movimiento autom√°ticamente.", correct: false },
                { text: "Desactivo temporalmente el shader principal y el cubo quedar√° sin animaci√≥n ni renderizado.", correct: false },
                { text: "Agrego una variable local 'stop=True' dentro del m√©todo update() para evitar que siga rotando.", correct: false }
              ]
            },
            {
              question: "¬øPara qu√© usamos las coordenadas uv en el Fragment Shader?",
              answers: [
                { text: "Las coordenadas uv las utilizamos en el Fragment Shader para mapear una textura sobre la superficie. Las coordenadas UV indican qu√© p√≠xel de la textura corresponde a cada fragmento que estamos renderizando.", correct: true },
                { text: "Se usan para calcular las posiciones relativas de las luces en el modelo seg√∫n su intensidad y direcci√≥n.", correct: false },
                { text: "Sirven para almacenar los valores de transparencia y reflejo de cada cara del modelo tridimensional.", correct: false },
                { text: "Las coordenadas uv controlan el orden de renderizado de las caras del objeto dentro del pipeline gr√°fico.", correct: false }
              ]
            },
            {
                "question": "¬øQu√© pasa visualmente si en el Vertex Shader no multiplicamos la posici√≥n de la figura primitiva por la matriz \"Mvp\" (Model-View-Projection)?",
                "answers": [
                    { "text": "El modelo aparecer√° renderizado sin texturas, mostrando solo sus colores base, porque la informaci√≥n de mapeo UV no se procesa adecuadamente sin la transformaci√≥n completa, afectando la correcta visualizaci√≥n del material.", "correct": false },
                    { "text": "Si en el Vertex Shader no multiplicamos la posici√≥n del v√©rtice por la matriz ‚ÄúMvp‚Äù, el objeto no se transforma correctamente al espacio de la c√°mara. Lo m√°s probable es que no se vea en pantalla, o se vea en una posici√≥n incorrecta ignorando la perspectiva y la ubicaci√≥n de la c√°mara.", "correct": true },
                    { "text": "El objeto se renderizar√° en el centro del mundo pero sin aplicar ninguna rotaci√≥n o escala, permaneciendo en su pose original y sin deformarse seg√∫n la vista del observador, aunque mantendr√° su posici√≥n relativa.", "correct": false },
                    { "text": "Se producir√° un error de compilaci√≥n en el shader, ya que la variable de salida gl_Position no recibir√° un valor v√°lido en coordenadas de recorte, lo que detendr√° por completo el pipeline de renderizado antes de dibujar.", "correct": false }
                ]
            },
            {
                "question": "¬øQu√© pasa si deshabilito el Depth Test?",
                "answers": [
                    { "text": "Al omitir el testeo de profundidad, la GPU renderiza los objetos en el orden en que fueron agregados a la escena, provocando que los √∫ltimos en ser a√±adidos siempre se visualicen por encima de los primeros, sin importar su lejan√≠a.", "correct": false },
                    { "text": "Desactivar esta funcionalidad provoca que solo se rendericen los objetos que se encuentran dentro del frustum de visi√≥n, descartando cualquier geometr√≠a que est√© parcialmente fuera de los l√≠mites definidos por los planos de la c√°mara.", "correct": false },
                    { "text": "Si deshabilito el Depth Test en el proyecto, OpenGL deja de realizar la prueba de profundidad y no detecta qu√© est√° ‚Äúpor delante‚Äù y qu√© ‚Äúpor detr√°s‚Äù, por lo que no oculta aquellos fragmentos que son ‚Äútapados‚Äù por otros.", "correct": true },
                    { "text": "Al desactivar la comprobaci√≥n de profundidad, los objetos m√°s lejanos se dibujar√°n siempre encima de los m√°s cercanos, invirtiendo el orden visual de la escena y generando un efecto de renderizado incorrecto conocido como z-fighting.", "correct": false }
                ]
            },
            {
                "question": "¬øEl Vertex-Fragment shader se ejecuta una vez por toda la escena o individualmente para cada objeto?",
                "answers": [
                    { "text": "El pipeline de renderizado se activa por cada material presente en la escena; todos los elementos que compartan el mismo material se procesan juntos en una √∫nica pasada del programa de sombreado para optimizar el rendimiento.", "correct": false },
                    { "text": "El Vertex-Fragment shader se ejecuta individualmente para cada objeto. Cada objeto tiene su propio draw call (vao.render), y en cada draw call el shader procesa todos los v√©rtices y fragmentos de ese objeto espec√≠fico.", "correct": true },
                    { "text": "El programa de shaders se invoca una √∫nica vez por cada frame, procesando la geometr√≠a de todos los modelos de la escena en un solo gran lote para minimizar las llamadas a la GPU y mejorar la eficiencia del dibujado.", "correct": false },
                    { "text": "La ejecuci√≥n del sombreador depende de la c√°mara; se lanza una vez por cada vista activa, procesando los modelos visibles desde esa perspectiva en un √∫nico ciclo de dibujado para generar la imagen correspondiente a ese punto de vista.", "correct": false }
                ]
            },
            {
                "question": "¬øCu√°l es la principal diferencia entre Raycasting y Raytracing?",
                "answers": [
                    { "text": "La principal diferencia es que Raycasting solo detecta si hay colisi√≥n entre el rayo y un objeto (informaci√≥n b√°sica). Raytracing utiliza el Raycasting para adem√°s calcular informaci√≥n detallada de la colisi√≥n como el color de la superficie, normales, reflexiones, refracciones y sombras para generar im√°genes realistas.", "correct": true },
                    { "text": "La distinci√≥n fundamental radica en el rendimiento; el primero es un m√©todo acelerado por hardware para consultas r√°pidas, mientras que el segundo es un algoritmo de software que se ejecuta en CPU para obtener resultados de alta fidelidad sin optimizaci√≥n de velocidad.", "correct": false },
                    { "text": "La separaci√≥n conceptual se basa en la cantidad de rayos lanzados; el primer m√©todo utiliza un √∫nico rayo para identificar un punto, mientras que el segundo emite un haz de rayos por p√≠xel para promediar resultados y conseguir efectos de desenfoque y antialiasing.", "correct": false },
                    { "text": "La divergencia clave est√° en el origen del rayo; en el primer caso, los rayos siempre parten de la c√°mara, pero en el segundo, los rayos se emiten desde las fuentes de luz para determinar qu√© superficies est√°n iluminadas antes de calcular la visibilidad de la escena.", "correct": false }
                ]
            },
            {
                "question": "¬øCu√°ntos Rays se trazan para renderizar un frame de pantalla? ¬øDe qu√© depende la cantidad?",
                "answers": [
                    { "text": "El n√∫mero de rayos lanzados es equivalente a la cantidad de v√©rtices totales en la escena, ya que se necesita un rayo por v√©rtice para determinar su visibilidad desde la c√°mara.", "correct": false },
                    { "text": "La cantidad de rayos emitidos por fotograma es igual al n√∫mero de objetos presentes, pues se lanza un rayo a cada uno para verificar su posici√≥n y tama√±o dentro del espacio.", "correct": false },
                    { "text": "Se traza un n√∫mero fijo de rayos, generalmente una potencia de dos como 1024, que se distribuyen por la pantalla para muestrear la escena y luego interpolar los colores.", "correct": false },
                    { "text": "Para renderizar un frame de pantalla, se traza un Ray por cada p√≠xel de la pantalla. Depende de la resoluci√≥n: si la pantalla es 800x600, se trazan 480,000 rayos.", "correct": true }
                ]
            },
            {
                "question": "¬øPor qu√© se utiliza un Quad en el proyecto de Raytracing?",
                "answers": [
                    { "text": "El Quad se emplea como una superficie de fondo para capturar las sombras proyectadas por los objetos de la escena, permitiendo que el algoritmo calcule correctamente las √°reas ocluidas por la luz.", "correct": false },
                    { "text": "Utilizamos un Quad en Raytracing porque funciona como una \"pantalla virtual\" donde se muestra el resultado del raytracing. La textura generada por el raytracer se mapea sobre el Quad para visualizarla.", "correct": true },
                    { "text": "Se emplea un Quad como el objeto principal de colisi√≥n en la escena, ya que su geometr√≠a plana simplifica los c√°lculos matem√°ticos iniciales para probar la l√≥gica de intersecci√≥n de los rayos.", "correct": false },
                    { "text": "Usamos el Quad para representar la fuente de luz principal en la escena; su superficie emite los rayos iniciales que luego rebotan en los objetos para simular la iluminaci√≥n de forma global.", "correct": false }
                ]
            },
            {
                "question": "¬øPor qu√© se utiliza el par√°metro hittable en la clase Hit?",
                "answers": [
                    { "text": "La variable hittable se emplea para activar o desactivar la capacidad de un objeto de proyectar sombras sobre otros modelos. Cuando es `False`, el objeto se vuelve transparente a los rayos de sombra, aunque sigue siendo visible.", "correct": false },
                    { "text": "El atributo hittable determina si un objeto puede ser seleccionado por el usuario mediante un clic del mouse. Si est√° en `False`, el sistema de raycasting lo omite, haci√©ndolo no interactivo pero aun visible en el render final.", "correct": false },
                    { "text": "El par√°metro hittable en la clase Hit lo utilizamos para controlar qu√© objetos deben considerarse en las colisiones del raytracing. Si hittable es False, el rayo ignora ese objeto (√∫til para el Quad de fondo, que solo sirve para mostrar la imagen y no debe colisionar).", "correct": true },
                    { "text": "Se usa la propiedad hittable para optimizar el rendimiento del renderizado. Cuando es `False`, el objeto se excluye del √°rbol BVH, por lo que no se prueba su intersecci√≥n, aunque todav√≠a se dibuja en el pipeline de rasterizaci√≥n.", "correct": false }
                ]
            },
            {
                "question": "Si al ejecutar el programa el quad se renderiza completamente en rojo, ¬øcu√°l es la causa m√°s probable y c√≥mo se soluciona?",
                "answers": [
                    { "text": "Si la pantalla renderiza completamente en rojo, puede ser porque el quad tiene configurada la propiedad ‚Äúhittable‚Äù en True. Tambi√©n puede ser que la cantidad de objetos que hay en escena ocupan todos y cada uno de los p√≠xeles de la pantalla. Se soluciona reduciendo la cantidad de objetos o indicando en la instancia del quad que su propiedad ‚Äúhittable‚Äù es False.", "correct": true },
                    { "text": "Un renderizado totalmente rojo indica un error en la matriz de proyecci√≥n, que est√° colapsando la escena. Para arreglarlo, se debe verificar que los planos `near` y `far` no sean negativos o est√©n invertidos, y que la relaci√≥n de aspecto de la c√°mara se calcule correctamente antes de renderizar.", "correct": false },
                    { "text": "El color rojo en toda la pantalla sugiere que el shader no est√° recibiendo la textura correcta. La soluci√≥n es revisar que el `binding` en Python coincida con el `sampler2D` en GLSL, y que el nombre del uniform sea el adecuado en el material asignado al quad.", "correct": false },
                    { "text": "Esto sucede cuando el buffer de profundidad no se limpia entre fotogramas. Para corregirlo, es necesario a√±adir una llamada a `ctx.clear(depth=True)` al inicio del bucle de renderizado, asegurando que cada frame se dibuje sobre un lienzo limpio y sin datos de profundidad antiguos.", "correct": false }
                ]
            },
            {
                "question": "En la escena de CPU ¬øD√≥nde configuramos el color del cielo?",
                "answers": [
                    { "text": "El tono del fondo se define directamente en el m√©todo `trace_ray` de la clase `RayTracer`, en la secci√≥n del `else` que se ejecuta cuando no hay colisiones.", "correct": false },
                    { "text": "Se establece en el archivo `main.py`, al crear la instancia de la textura de fondo que posteriormente se asigna como parte del material del Quad principal.", "correct": false },
                    { "text": "En la clase Camera, usando el m√©todo set_sky_colors() que define los colores superior e inferior del degradado del cielo.", "correct": true },
                    { "text": "Lo ajustamos en la clase `Scene`, a trav√©s de una propiedad global que establece un color de limpieza para el contexto de OpenGL antes de cada ciclo de renderizado.", "correct": false }
                ]
            },
            {
                "question": "En raytracing por CPU ¬øD√≥nde realizamos el trazado de rayos? ¬øQu√© da como resultado?",
                "answers": [
                    { "text": "El proceso se lleva a cabo en la funci√≥n `on_mouse_click` de la clase `Scene` y genera una lista de objetos intersectados que se imprimen en consola, sin producir una imagen directamente, solo datos de colisi√≥n.", "correct": false },
                    { "text": "El c√°lculo de rayos ocurre en `render_frame` de la clase `RayTracer`. El producto final es un archivo de imagen en formato PNG que se guarda en el disco y debe cargarse manualmente para poder ser visualizado.", "correct": false },
                    { "text": "En raytracing por CPU trazamos los rayos en el m√©todo trace_ray de la clase RayTracer. Da como resultado un ImageData (matriz numpy) donde cada p√≠xel tiene el color calculado seg√∫n si el rayo colision√≥ con un objeto o con el cielo. Este ImageData luego se convierte a bytes y se carga como textura en el Quad.", "correct": true },
                    { "text": "El trazado se ejecuta dentro del constructor de la clase `RayScene`. El resultado es una modificaci√≥n de los colores de los v√©rtices de los objetos, que luego son interpolados por el pipeline de rasterizaci√≥n para dibujar la imagen.", "correct": false }
                ]
            },
            {
                "question": "¬øPor qu√© el raytracing en CPU es m√°s lento que en GPU?",
                "answers": [
                    { "text": "La diferencia de velocidad radica en el acceso a la memoria. La CPU tiene mayor latencia al leer los datos de la RAM, mientras que la GPU opera sobre su VRAM de alta velocidad, donde la geometr√≠a y texturas est√°n disponibles sin cuellos de botella.", "correct": false },
                    { "text": "El rendimiento inferior en la CPU se explica por la falta de librer√≠as optimizadas. La GPU utiliza drivers como OpenGL que gestionan el renderizado de manera eficiente, algo que debe simularse por software en el procesador principal, generando penalizaci√≥n.", "correct": false },
                    { "text": "La lentitud en la unidad central de procesamiento se debe a que las operaciones de punto flotante son menos precisas, requiriendo c√°lculos adicionales de correcci√≥n de errores, mientras que las unidades gr√°ficas tienen hardware especializado.", "correct": false },
                    { "text": "El raytracing es m√°s lento en CPU que en GPU porque en CPU los rayos se procesan secuencialmente uno tras otro (un solo n√∫cleo o pocos n√∫cleos). En GPU se usan work groups que procesan miles de rayos en paralelo simult√°neamente, aprovechando los miles de n√∫cleos de la GPU.", "correct": true }
                ]
            },
            {
                "question": "En la escena de GPU ¬øD√≥nde configuramos el color del cielo? ¬øCrees que se puede obtener de los archivos de Python? ¬øC√≥mo se los paso al shader?",
                "answers": [
                    { "text": "El color del cielo se configura en el Compute Shader, en la parte del c√≥digo que se ejecuta cuando el rayo no colisiona con ning√∫n objeto. S√≠, se puede obtener de Python: tomamos los colores de la clase Camera en la clase RaytracerGPU y los pasamos al shader como uniforms de tipo vec3.", "correct": true },
                    { "text": "El tono del fondo se establece como el color de limpieza del contexto de ModernGL. Es posible configurarlo desde Python, pero el shader no puede modificarlo; simplemente renderiza sobre el fondo ya pintado, dejando transparentes las zonas sin colisi√≥n.", "correct": false },
                    { "text": "El color del cielo se carga a trav√©s de una textura `samplerCube` que se env√≠a al shader como un SSBO. Desde Python, se deben generar las seis caras del cubo y empaquetarlas en un buffer para que el shader pueda muestrear el cielo seg√∫n la direcci√≥n.", "correct": false },
                    { "text": "Se define en el Fragment Shader que renderiza el Quad, no en el Compute Shader. El color se pasa como un atributo de v√©rtice desde Python, interpol√°ndose entre los v√©rtices del Quad para crear el gradiente, mientras el Compute Shader solo se encarga de los objetos.", "correct": false }
                ]
            },
            {
                "question": "En raytracing por GPU ¬øD√≥nde realizamos el trazado de rayos? ¬øQu√© da como resultado?",
                "answers": [
                    { "text": "El trazado se ejecuta en el Vertex Shader, modificando las posiciones de los v√©rtices de una malla plana para formar la imagen. El Fragment Shader solo aplica un color uniforme a esta geometr√≠a deformada por los rayos.", "correct": false },
                    { "text": "El c√°lculo de rayos se realiza en la clase `RaytracerGPU` en Python. El producto es una lista de colores que se env√≠a al Fragment Shader a trav√©s de un `uniform array` para pintar cada p√≠xel del quad de salida.", "correct": false },
                    { "text": "En raytracing por GPU los rayos se trazan en el m√©todo main() del Compute Shader. Da como resultado una textura de OpenGL donde cada p√≠xel se escribe directamente en la GPU seg√∫n si el rayo colision√≥ con un objeto o con el cielo.", "correct": true },
                    { "text": "La traza de rayos ocurre en un hilo separado en la CPU, que genera un buffer de p√≠xeles y se sube a la GPU en cada frame. El Compute Shader se limita a leer este buffer y copiarlo a la textura de salida.", "correct": false }
                ]
            },
            {
                "question": "¬øQu√© diferencia hay entre las clases Raytracer y RaytracerGPU?",
                "answers": [
                    { "text": "La distinci√≥n es que la versi√≥n de CPU realiza c√°lculos de iluminaci√≥n de forma local p√≠xel a p√≠xel, mientras que la variante para la unidad gr√°fica se encarga de preparar los buffers de v√©rtices y enviarlos a un pipeline de renderizado tradicional, delegando solo el sombreado final.", "correct": false },
                    { "text": "La clase Raytracer (CPU) ejecuta el algoritmo de trazado de rayos en Python p√≠xel por p√≠xel y genera un ImageData que se pasa a bytes y se guardan en la textura que luego se renderiza en el Quad. Es decir, hace todo el raytracing. La clase RaytracerGPU prepara y env√≠a los datos (SSBOs) al Compute Shader para que la GPU haga todo el trazado en paralelo. Es decir, prepara los datos que necesita el shader y no ocurre el raytracing en la misma clase, lo delega a la GPU.", "correct": true },
                    { "text": "La primera implementa un sistema b√°sico que solo detecta colisiones y las muestra en consola, sin generar una imagen. La segunda, en cambio, utiliza esos mismos c√°lculos de colisi√≥n para construir una representaci√≥n visual completa con colores y materiales, procesando todo en la tarjeta de video.", "correct": false },
                    { "text": "La versi√≥n para el procesador central emite rayos desde las luces para calcular sombras, mientras que la clase para la unidad de procesamiento gr√°fico lanza rayos desde la c√°mara para determinar la visibilidad. Ambas deben combinarse para obtener la imagen final con iluminaci√≥n y oclusi√≥n.", "correct": false }
                ]
            },
            {
                "question": "¬øPor qu√© usamos un Compute Shader y no el tradicional Vertex-Fragment shader?",
                "answers": [
                    { "text": "Se emplea un programa de c√≥mputo porque es la √∫nica forma de escribir directamente sobre una textura en la memoria de la GPU, mientras que el pipeline cl√°sico solo puede dibujar en el framebuffer principal de la pantalla, lo que limita los efectos de post-procesado.", "correct": false },
                    { "text": "La raz√≥n principal es el rendimiento; los sombreadores de c√≥mputo son una tecnolog√≠a m√°s moderna y est√°n optimizados para ejecutar cualquier tipo de algoritmo matem√°tico de forma mucho m√°s r√°pida que el pipeline gr√°fico tradicional de v√©rtices y fragmentos.", "correct": false },
                    { "text": "Usamos Compute Shader para raytracing y no el cl√°sico Vertex-Fragment shader porque necesitamos acceder a informaci√≥n de toda la escena simult√°neamente para trazar rayos desde cualquier p√≠xel hacia todos los objetos. El Vertex-Fragment shader est√° dise√±ado para procesar un objeto a la vez, mientras que el Compute Shader puede trabajar con toda la escena de forma global y paralela.", "correct": true },
                    { "text": "La elecci√≥n se debe a que los sombreadores de v√©rtices y fragmentos no pueden manejar estructuras de datos complejas como arrays o matrices, limit√°ndose a variables simples. El sombreador de c√≥mputo es necesario para poder enviar toda la informaci√≥n de la escena.", "correct": false }
                ]
            },
            {
                "question": "¬øC√≥mo se guardan datos complejos para enviar al Compute Shader?",
                "answers": [
                    { "text": "Para transferir informaci√≥n elaborada al programa de c√≥mputo, esta se codifica en los canales de color de una textura de datos, que el sombreador lee como una imagen para extraer la informaci√≥n de matrices y vectores.", "correct": false },
                    { "text": "La informaci√≥n se transmite utilizando una lista de uniforms. Cada objeto de la escena tiene su propio conjunto de variables globales que se actualizan desde Python antes de ejecutar el programa de c√≥mputo en la GPU.", "correct": false },
                    { "text": "Se env√≠an como atributos de un √∫nico v√©rtice gigante que se pasa al programa de c√≥mputo. Cada atributo contiene un fragmento de la informaci√≥n de la escena, como las matrices de transformaci√≥n o los materiales.", "correct": false },
                    { "text": "Para enviar al Compute Shader datos complejos, se guardan en SSBOs (Shader Storage Buffer Objects), que son buffers que pueden almacenar estructuras de datos complejas (arrays de matrices, vectores, structs, etc.) accesibles desde el shader.", "correct": true }
                ]
            },
            {
                "question": "¬øPor qu√© usamos SSBOs?",
                "answers": [
                    { "text": "Utilizamos estos buffers de almacenamiento porque son la √∫nica manera de permitir que el programa de c√≥mputo escriba resultados, ya que las variables uniformes son de solo lectura y no pueden modificarse desde la GPU.", "correct": false },
                    { "text": "Los empleamos principalmente por su velocidad de acceso, ya que residen en una cach√© especial de la GPU que es mucho m√°s r√°pida que la memoria utilizada por las variables uniformes tradicionales, optimizando el rendimiento.", "correct": false },
                    { "text": "Usamos SSBOs porque necesitamos enviar grandes cantidades de datos estructurados al shader (como las transformaciones de todos los objetos, sus materiales, el BVH, etc.) y los uniforms tradicionales tienen l√≠mites de tama√±o muy peque√±os.", "correct": true },
                    { "text": "Se usan porque garantizan que la disposici√≥n de los datos en la memoria de la GPU sea id√©ntica a la de la CPU, evitando problemas de alineaci√≥n que ocurrir√≠an si se usaran otros tipos de buffers para estructuras complejas.", "correct": false }
                ]
            },
            {
                "question": "¬øC√≥mo se declara un SSBO en el compute shader?",
                "answers": [
                    { "text": "En el sombreador, se define con la directiva `uniform buffer` y se le asigna un nombre y un conjunto de variables internas.", "correct": false },
                    { "text": "Un SSBO se declara en el shader con la palabra clave \"buffer\" seguida del layout de binding.", "correct": true },
                    { "text": "Se utiliza la palabra reservada `storage` junto con un `layout` que especifica el √≠ndice de la unidad de memoria asignada.", "correct": false },
                    { "text": "Se define mediante la palabra clave `shared` para indicar que es una memoria accesible tanto para lectura como para escritura.", "correct": false }
                ]
            },
            {
                "question": "¬øQu√© importa m√°s: el binding o el nombre de la variable?",
                "answers": [
                    { "text": "El nombre es m√°s relevante, ya que es la forma en que el c√≥digo de Python identifica el recurso al que se est√° enviando la informaci√≥n.", "correct": false },
                    { "text": "Ambos son igualmente importantes; si el nombre de la variable o el √≠ndice de enlace no coinciden, la conexi√≥n de datos fallar√°.", "correct": false },
                    { "text": "Importa m√°s el binding que el nombre de la variable. El binding indica la ubicaci√≥n exacta en memoria donde est√°n los datos. El nombre de la variable es s√≥lo para referencia interna del shader.", "correct": true },
                    { "text": "Ninguno de los dos es crucial, ya que los datos se vinculan por el orden en que se declaran, siendo el primer buffer el √≠ndice 0, el segundo el 1, etc.", "correct": false }
                ]
            },
            {
                "question": "¬øQu√© guarda la variable models_f? ¬øPara qu√© se usa?",
                "answers": [
                    { "text": "Almacena las matrices de proyecci√≥n y vista de la c√°mara, que se usan para convertir las coordenadas de los v√©rtices al espacio de la pantalla.", "correct": false },
                    { "text": "En la variable models_f se guardan las matrices de transformaci√≥n modelo (Model matrix) de cada objeto en la escena. Se usa para transformar los objetos de su espacio local al espacio del mundo.", "correct": true },
                    { "text": "Contiene los datos de los v√©rtices de todos los modelos de la escena, que se leen para realizar los c√°lculos de intersecci√≥n de los rayos.", "correct": false },
                    { "text": "Guarda una lista de colores de material para cada objeto, que se aplica a los p√≠xeles cuando un rayo impacta en una superficie.", "correct": false }
                ]
            },
            {
                "question": "¬øQu√© guarda la variable inv_f? ¬øPara qu√© se usa?",
                "answers": [
                    { "text": "Conserva las matrices que invierten la proyecci√≥n de la c√°mara, utilizadas para calcular la posici√≥n 3D a partir de una coordenada 2D de la pantalla.", "correct": false },
                    { "text": "Almacena las matrices que anulan la rotaci√≥n de los objetos, permitiendo que los c√°lculos de iluminaci√≥n se realicen como si no estuvieran girados.", "correct": false },
                    { "text": "En la variable inv_f se guardan las matrices inversas de transformaci√≥n de cada objeto. Se usa para transformar los rayos del espacio del mundo al espacio local de cada objeto, facilitando el c√°lculo de colisiones en las coordenadas originales del objeto.", "correct": true },
                    { "text": "Contiene las matrices opuestas a las de vista, que se emplean para posicionar la fuente de luz en el sistema de coordenadas de la c√°mara.", "correct": false }
                ]
            },
            {
                "question": "¬øQu√© guarda la variable mats_f? ¬øPara qu√© se usa?",
                "answers": [
                    { "text": "Almacena una lista de matrices de textura para cada objeto, que se emplean para mapear correctamente las coordenadas UV en las superficies.", "correct": false },
                    { "text": "Contiene las matrices de rotaci√≥n de cada objeto, que se utilizan para calcular la orientaci√≥n de las normales de las superficies al aplicar la iluminaci√≥n.", "correct": false },
                    { "text": "En la variable mats_f se guarda la informaci√≥n de los materiales de cada objeto (colores y propiedades como reflectividad). Se usa para calcular el color final de los p√≠xeles al renderizar.", "correct": true },
                    { "text": "Guarda las matrices de escala de cada modelo, que se aplican para determinar el tama√±o de las cajas de colisi√≥n en el algoritmo de BVH.", "correct": false }
                ]
            },
            {
                "question": "¬øQu√© guarda la variable primitives? ¬øPara qu√© se usa?",
                "answers": [
                    { "text": "La variable primitives guarda informaci√≥n de las primitivas geom√©tricas (como los v√©rtices o bounds de los objetos). Se usa para construir y recorrer el BVH al hacer las pruebas de colisi√≥n.", "correct": true },
                    { "text": "Contiene los √≠ndices que definen los tri√°ngulos de cada modelo, utilizados por el pipeline de rasterizaci√≥n para dibujar las mallas.", "correct": false },
                    { "text": "Almacena los tipos de geometr√≠a de cada objeto (cubo, esfera, etc.), permitiendo al shader elegir el algoritmo de intersecci√≥n adecuado.", "correct": false },
                    { "text": "Guarda los colores base de cada primitiva, que se leen para aplicar el sombreado plano antes de los c√°lculos de iluminaci√≥n complejos.", "correct": false }
                ]
            },
            {
                "question": "En resumidas palabras ¬øPara qu√© usamos el BVH?",
                "answers": [
                    { "text": "Se utiliza para almacenar la geometr√≠a de la escena en un formato comprimido que reduce el uso de memoria en la tarjeta gr√°fica y acelera los tiempos de carga.", "correct": false },
                    { "text": "Lo empleamos para determinar el orden de renderizado de los objetos, dibujando primero los m√°s cercanos a la c√°mara para aprovechar la oclusi√≥n y mejorar el rendimiento.", "correct": false },
                    { "text": "Usamos el BVH para optimizar las colisiones organizando los objetos en una jerarqu√≠a espacial. Permite descartar r√°pidamente grupos enteros de objetos que no pueden ser alcanzados por un rayo, evitando hacer pruebas de colisi√≥n innecesarias (como ver si un rayo que va hacia la derecha colisiona con un objeto que est√° en la izquierda).", "correct": true },
                    { "text": "Sirve para subdividir los modelos m√°s complejos en mallas de menor resoluci√≥n (LODs), que se seleccionan seg√∫n la distancia a la c√°mara para optimizar el dibujado.", "correct": false }
                ]
            },
            {
                "question": "¬øQu√© efecto visual obtenemos si la luz es completamente perpendicular a la superficie?",
                "answers": [
                    { "text": "Se genera un brillo especular muy intenso en el punto de incidencia, ya que el √°ngulo de reflexi√≥n coincide perfectamente con la normal.", "correct": false },
                    { "text": "Una luz completamente perpendicular a la superficie la ilumina al m√°ximo (m√°xima intensidad), ya que recibe la luz directamente de frente.", "correct": true },
                    { "text": "La superficie no recibe iluminaci√≥n directa, apareciendo oscura, ya que los rayos de luz inciden de forma rasante y no la alcanzan.", "correct": false },
                    { "text": "Produce una sombra muy n√≠tida y definida detr√°s del objeto, porque el √°ngulo de incidencia maximiza la oclusi√≥n de la luz.", "correct": false }
                ]
            },
            {
                "question": "¬øQu√© efecto visual obtenemos si la luz es completamente paralela a la superficie?",
                "answers": [
                    { "text": "Se produce el m√°ximo brillo difuso, ya que la energ√≠a lum√≠nica se distribuye uniformemente a lo largo de toda el √°rea expuesta.", "correct": false },
                    { "text": "Se crea un contorno iluminado muy marcado, conocido como 'rim lighting', que resalta la silueta del objeto contra el fondo.", "correct": false },
                    { "text": "Una luz completamente paralela a la superficie la deja sin iluminaci√≥n (solo se ve la luz ambiental), ya que la luz no incide sobre ella sino que pasa de largo.", "correct": true },
                    { "text": "Genera un reflejo especular muy alargado a lo largo de la superficie, ya que los rayos se reflejan en un √°ngulo muy bajo.", "correct": false }
                ]
            },
            {
                "question": "¬øQu√© efecto visual a√±ade la luz ambiental?",
                "answers": [
                    { "text": "La luz ambiental proporciona iluminaci√≥n base uniforme a toda la escena. Hace que los objetos sean visibles incluso en zonas sin luz directa, evitando sombras completamente negras.", "correct": true },
                    { "text": "Este componente lum√≠nico crea reflejos brillantes y n√≠tidos en las superficies pulidas, simulando el comportamiento de materiales como los metales.", "correct": false },
                    { "text": "Produce un sombreado suave que define el volumen de los objetos, haciendo que las caras orientadas hacia la luz se vean m√°s claras que las dem√°s.", "correct": false },
                    { "text": "Genera halos y destellos alrededor de las fuentes de luz m√°s intensas, simulando efectos atmosf√©ricos como el resplandor o la niebla.", "correct": false }
                ]
            },
            {
                "question": "¬øQu√© efecto visual a√±ade la luz difusa?",
                "answers": [
                    { "text": "Este tipo de iluminaci√≥n simula la luz que rebota en el entorno, rellenando las √°reas en sombra con un color suave y evitando el negro absoluto.", "correct": false },
                    { "text": "La luz difusa crea el efecto de sombreado en las superficies seg√∫n el √°ngulo de la luz. Las caras perpendiculares a la luz se ven m√°s claras y las paralelas m√°s oscuras, dando volumen al objeto.", "correct": true },
                    { "text": "A√±ade reflejos especulares muy concentrados en las superficies, lo que simula el brillo caracter√≠stico de los materiales pulidos o h√∫medos.", "correct": false },
                    { "text": "Es responsable de la transparencia y la refracci√≥n, calculando c√≥mo la luz atraviesa los materiales y desv√≠a su trayectoria, como en el vidrio o el agua.", "correct": false }
                ]
            },
            {
                "question": "¬øQu√© efecto visual a√±ade la luz especular?",
                "answers": [
                    { "text": "La luz especular crea brillos o reflejos puntuales en las superficies, simulando materiales brillantes o pulidos. Se ve m√°s intenso cuando el √°ngulo de reflexi√≥n coincide con la direcci√≥n de la c√°mara.", "correct": true },
                    { "text": "Este componente lum√≠nico proporciona una iluminaci√≥n constante a toda la escena, asegurando que ninguna parte quede completamente oscura.", "correct": false },
                    { "text": "Crea el sombreado principal de los objetos, haciendo que las caras que apuntan hacia la fuente de luz se vean m√°s iluminadas y con volumen.", "correct": false },
                    { "text": "Es la responsable de proyectar las sombras de los objetos sobre otras superficies, calculando las √°reas que est√°n ocluidas de la luz.", "correct": false }
                ]
            },
            {
                "question": "¬øC√≥mo obtenemos una escena con sombras m√°s oscuras (o menos suaves)?",
                "answers": [
                    { "text": "Para obtener sombras menos suaves, en el m√©todo calculateShadow del Compute Shader reducimos el porcentaje de luz que se devuelve cuando el rayo hace hit (est√° en sombra). Valores m√°s bajos generan sombras m√°s oscuras.", "correct": true },
                    { "text": "Se logra aumentando la intensidad del componente de luz ambiental en el modelo de iluminaci√≥n, lo que rellena las √°reas ocluidas con m√°s brillo y las hace menos intensas.", "correct": false },
                    { "text": "Para conseguir un efecto m√°s marcado, se debe incrementar el exponente especular en el c√°lculo de Blinn-Phong, concentrando el brillo y oscureciendo el resto de la superficie.", "correct": false },
                    { "text": "Se consigue al disminuir la distancia del `far plane` de la c√°mara, lo que comprime el rango de profundidad y provoca que el `depth buffer` tenga menos precisi√≥n en las zonas lejanas.", "correct": false }
                ]
            },
            
            // Parte 3: Exclusivas de conceptos vistos en el apartado para Proyecto en Grupo:
            {
                "question": "¬øQu√© diferencia hay entre las clases Raytracer y RaytracerGPU?",
                "answers": [
                    { "text": "La distinci√≥n es que la versi√≥n de CPU realiza c√°lculos de iluminaci√≥n de forma local p√≠xel a p√≠xel, mientras que la variante para la unidad gr√°fica se encarga de preparar los buffers de v√©rtices y enviarlos a un pipeline de renderizado tradicional, delegando solo el sombreado final.", "correct": false },
                    { "text": "La clase Raytracer (CPU) ejecuta el algoritmo de trazado de rayos en Python p√≠xel por p√≠xel y genera un ImageData que se pasa a bytes y se guardan en la textura que luego se renderiza en el Quad. Es decir, hace todo el raytracing. La clase RaytracerGPU prepara y env√≠a los datos (SSBOs) al Compute Shader para que la GPU haga todo el trazado en paralelo. Es decir, prepara los datos que necesita el shader y no ocurre el raytracing en la misma clase, lo delega a la GPU.", "correct": true },
                    { "text": "La primera implementa un sistema b√°sico que solo detecta colisiones y las muestra en consola, sin generar una imagen. La segunda, en cambio, utiliza esos mismos c√°lculos de colisi√≥n para construir una representaci√≥n visual completa con colores y materiales, procesando todo en la tarjeta de video.", "correct": false },
                    { "text": "La versi√≥n para el procesador central emite rayos desde las luces para calcular sombras, mientras que la clase para la unidad de procesamiento gr√°fico lanza rayos desde la c√°mara para determinar la visibilidad. Ambas deben combinarse para obtener la imagen final con iluminaci√≥n y oclusi√≥n.", "correct": false }
                ]
            },
            {
                "question": "¬øPor qu√© usamos un Compute Shader y no el tradicional Vertex-Fragment shader?",
                "answers": [
                    { "text": "Se emplea un programa de c√≥mputo porque es la √∫nica forma de escribir directamente sobre una textura en la memoria de la GPU, mientras que el pipeline cl√°sico solo puede dibujar en el framebuffer principal de la pantalla, lo que limita los efectos de post-procesado.", "correct": false },
                    { "text": "La raz√≥n principal es el rendimiento; los sombreadores de c√≥mputo son una tecnolog√≠a m√°s moderna y est√°n optimizados para ejecutar cualquier tipo de algoritmo matem√°tico de forma mucho m√°s r√°pida que el pipeline gr√°fico tradicional de v√©rtices y fragmentos.", "correct": false },
                    { "text": "Usamos Compute Shader para raytracing y no el cl√°sico Vertex-Fragment shader porque necesitamos acceder a informaci√≥n de toda la escena simult√°neamente para trazar rayos desde cualquier p√≠xel hacia todos los objetos. El Vertex-Fragment shader est√° dise√±ado para procesar un objeto a la vez, mientras que el Compute Shader puede trabajar con toda la escena de forma global y paralela.", "correct": true },
                    { "text": "La elecci√≥n se debe a que los sombreadores de v√©rtices y fragmentos no pueden manejar estructuras de datos complejas como arrays o matrices, limit√°ndose a variables simples. El sombreador de c√≥mputo es necesario para poder enviar toda la informaci√≥n de la escena.", "correct": false }
                ]
            },
            {
                "question": "¬øC√≥mo se guardan datos complejos para enviar al Compute Shader?",
                "answers": [
                    { "text": "Para transferir informaci√≥n elaborada al programa de c√≥mputo, esta se codifica en los canales de color de una textura de datos, que el sombreador lee como una imagen para extraer la informaci√≥n de matrices y vectores.", "correct": false },
                    { "text": "La informaci√≥n se transmite utilizando una lista de uniforms. Cada objeto de la escena tiene su propio conjunto de variables globales que se actualizan desde Python antes de ejecutar el programa de c√≥mputo en la GPU.", "correct": false },
                    { "text": "Se env√≠an como atributos de un √∫nico v√©rtice gigante que se pasa al programa de c√≥mputo. Cada atributo contiene un fragmento de la informaci√≥n de la escena, como las matrices de transformaci√≥n o los materiales.", "correct": false },
                    { "text": "Para enviar al Compute Shader datos complejos, se guardan en SSBOs (Shader Storage Buffer Objects), que son buffers que pueden almacenar estructuras de datos complejas (arrays de matrices, vectores, structs, etc.) accesibles desde el shader.", "correct": true }
                ]
            },
            {
                "question": "¬øPor qu√© usamos SSBOs?",
                "answers": [
                    { "text": "Utilizamos estos buffers de almacenamiento porque son la √∫nica manera de permitir que el programa de c√≥mputo escriba resultados, ya que las variables uniformes son de solo lectura y no pueden modificarse desde la GPU.", "correct": false },
                    { "text": "Los empleamos principalmente por su velocidad de acceso, ya que residen en una cach√© especial de la GPU que es mucho m√°s r√°pida que la memoria utilizada por las variables uniformes tradicionales, optimizando el rendimiento.", "correct": false },
                    { "text": "Usamos SSBOs porque necesitamos enviar grandes cantidades de datos estructurados al shader (como las transformaciones de todos los objetos, sus materiales, el BVH, etc.) y los uniforms tradicionales tienen l√≠mites de tama√±o muy peque√±os.", "correct": true },
                    { "text": "Se usan porque garantizan que la disposici√≥n de los datos en la memoria de la GPU sea id√©ntica a la de la CPU, evitando problemas de alineaci√≥n que ocurrir√≠an si se usaran otros tipos de buffers para estructuras complejas.", "correct": false }
                ]
            },
            {
                "question": "¬øC√≥mo se declara un SSBO en el compute shader?",
                "answers": [
                    { "text": "En el sombreador, se define con la directiva `uniform buffer` y se le asigna un nombre y un conjunto de variables internas.", "correct": false },
                    { "text": "Un SSBO se declara en el shader con la palabra clave \"buffer\" seguida del layout de binding.", "correct": true },
                    { "text": "Se utiliza la palabra reservada `storage` junto con un `layout` que especifica el √≠ndice de la unidad de memoria asignada.", "correct": false },
                    { "text": "Se define mediante la palabra clave `shared` para indicar que es una memoria accesible tanto para lectura como para escritura.", "correct": false }
                ]
            },
            {
                "question": "¬øQu√© importa m√°s: el binding o el nombre de la variable?",
                "answers": [
                    { "text": "El nombre es m√°s relevante, ya que es la forma en que el c√≥digo de Python identifica el recurso al que se est√° enviando la informaci√≥n.", "correct": false },
                    { "text": "Ambos son igualmente importantes; si el nombre de la variable o el √≠ndice de enlace no coinciden, la conexi√≥n de datos fallar√°.", "correct": false },
                    { "text": "Importa m√°s el binding que el nombre de la variable. El binding indica la ubicaci√≥n exacta en memoria donde est√°n los datos. El nombre de la variable es s√≥lo para referencia interna del shader.", "correct": true },
                    { "text": "Ninguno de los dos es crucial, ya que los datos se vinculan por el orden en que se declaran, siendo el primer buffer el √≠ndice 0, el segundo el 1, etc.", "correct": false }
                ]
            },
            {
                "question": "¬øQu√© guarda la variable models_f? ¬øPara qu√© se usa?",
                "answers": [
                    { "text": "Almacena las matrices de proyecci√≥n y vista de la c√°mara, que se usan para convertir las coordenadas de los v√©rtices al espacio de la pantalla.", "correct": false },
                    { "text": "En la variable models_f se guardan las matrices de transformaci√≥n modelo (Model matrix) de cada objeto en la escena. Se usa para transformar los objetos de su espacio local al espacio del mundo.", "correct": true },
                    { "text": "Contiene los datos de los v√©rtices de todos los modelos de la escena, que se leen para realizar los c√°lculos de intersecci√≥n de los rayos.", "correct": false },
                    { "text": "Guarda una lista de colores de material para cada objeto, que se aplica a los p√≠xeles cuando un rayo impacta en una superficie.", "correct": false }
                ]
            },
            {
                "question": "¬øQu√© guarda la variable inv_f? ¬øPara qu√© se usa?",
                "answers": [
                    { "text": "Conserva las matrices que invierten la proyecci√≥n de la c√°mara, utilizadas para calcular la posici√≥n 3D a partir de una coordenada 2D de la pantalla.", "correct": false },
                    { "text": "Almacena las matrices que anulan la rotaci√≥n de los objetos, permitiendo que los c√°lculos de iluminaci√≥n se realicen como si no estuvieran girados.", "correct": false },
                    { "text": "En la variable inv_f se guardan las matrices inversas de transformaci√≥n de cada objeto. Se usa para transformar los rayos del espacio del mundo al espacio local de cada objeto, facilitando el c√°lculo de colisiones en las coordenadas originales del objeto.", "correct": true },
                    { "text": "Contiene las matrices opuestas a las de vista, que se emplean para posicionar la fuente de luz en el sistema de coordenadas de la c√°mara.", "correct": false }
                ]
            },
            {
                "question": "¬øQu√© guarda la variable mats_f? ¬øPara qu√© se usa?",
                "answers": [
                    { "text": "Almacena una lista de matrices de textura para cada objeto, que se emplean para mapear correctamente las coordenadas UV en las superficies.", "correct": false },
                    { "text": "Contiene las matrices de rotaci√≥n de cada objeto, que se utilizan para calcular la orientaci√≥n de las normales de las superficies al aplicar la iluminaci√≥n.", "correct": false },
                    { "text": "En la variable mats_f se guarda la informaci√≥n de los materiales de cada objeto (colores y propiedades como reflectividad). Se usa para calcular el color final de los p√≠xeles al renderizar.", "correct": true },
                    { "text": "Guarda las matrices de escala de cada modelo, que se aplican para determinar el tama√±o de las cajas de colisi√≥n en el algoritmo de BVH.", "correct": false }
                ]
            },
            {
                "question": "¬øQu√© guarda la variable primitives? ¬øPara qu√© se usa?",
                "answers": [
                    { "text": "La variable primitives guarda informaci√≥n de las primitivas geom√©tricas (como los v√©rtices o bounds de los objetos). Se usa para construir y recorrer el BVH al hacer las pruebas de colisi√≥n.", "correct": true },
                    { "text": "Contiene los √≠ndices que definen los tri√°ngulos de cada modelo, utilizados por el pipeline de rasterizaci√≥n para dibujar las mallas.", "correct": false },
                    { "text": "Almacena los tipos de geometr√≠a de cada objeto (cubo, esfera, etc.), permitiendo al shader elegir el algoritmo de intersecci√≥n adecuado.", "correct": false },
                    { "text": "Guarda los colores base de cada primitiva, que se leen para aplicar el sombreado plano antes de los c√°lculos de iluminaci√≥n complejos.", "correct": false }
                ]
            },
            {
                "question": "En resumidas palabras ¬øPara qu√© usamos el BVH?",
                "answers": [
                    { "text": "Se utiliza para almacenar la geometr√≠a de la escena en un formato comprimido que reduce el uso de memoria en la tarjeta gr√°fica y acelera los tiempos de carga.", "correct": false },
                    { "text": "Lo empleamos para determinar el orden de renderizado de los objetos, dibujando primero los m√°s cercanos a la c√°mara para aprovechar la oclusi√≥n y mejorar el rendimiento.", "correct": false },
                    { "text": "Usamos el BVH para optimizar las colisiones organizando los objetos en una jerarqu√≠a espacial. Permite descartar r√°pidamente grupos enteros de objetos que no pueden ser alcanzados por un rayo, evitando hacer pruebas de colisi√≥n innecesarias (como ver si un rayo que va hacia la derecha colisiona con un objeto que est√° en la izquierda).", "correct": true },
                    { "text": "Sirve para subdividir los modelos m√°s complejos en mallas de menor resoluci√≥n (LODs), que se seleccionan seg√∫n la distancia a la c√°mara para optimizar el dibujado.", "correct": false }
                ]
            },
            {
                "question": "¬øQu√© efecto visual obtenemos si la luz es completamente perpendicular a la superficie?",
                "answers": [
                    { "text": "Se genera un brillo especular muy intenso en el punto de incidencia, ya que el √°ngulo de reflexi√≥n coincide perfectamente con la normal.", "correct": false },
                    { "text": "Una luz completamente perpendicular a la superficie la ilumina al m√°ximo (m√°xima intensidad), ya que recibe la luz directamente de frente.", "correct": true },
                    { "text": "La superficie no recibe iluminaci√≥n directa, apareciendo oscura, ya que los rayos de luz inciden de forma rasante y no la alcanzan.", "correct": false },
                    { "text": "Produce una sombra muy n√≠tida y definida detr√°s del objeto, porque el √°ngulo de incidencia maximiza la oclusi√≥n de la luz.", "correct": false }
                ]
            },
            {
                "question": "¬øQu√© efecto visual obtenemos si la luz es completamente paralela a la superficie?",
                "answers": [
                    { "text": "Se produce el m√°ximo brillo difuso, ya que la energ√≠a lum√≠nica se distribuye uniformemente a lo largo de toda el √°rea expuesta.", "correct": false },
                    { "text": "Se crea un contorno iluminado muy marcado, conocido como 'rim lighting', que resalta la silueta del objeto contra el fondo.", "correct": false },
                    { "text": "Una luz completamente paralela a la superficie la deja sin iluminaci√≥n (solo se ve la luz ambiental), ya que la luz no incide sobre ella sino que pasa de largo.", "correct": true },
                    { "text": "Genera un reflejo especular muy alargado a lo largo de la superficie, ya que los rayos se reflejan en un √°ngulo muy bajo.", "correct": false }
                ]
            },
            {
                "question": "¬øQu√© efecto visual a√±ade la luz ambiental?",
                "answers": [
                    { "text": "La luz ambiental proporciona iluminaci√≥n base uniforme a toda la escena. Hace que los objetos sean visibles incluso en zonas sin luz directa, evitando sombras completamente negras.", "correct": true },
                    { "text": "Este componente lum√≠nico crea reflejos brillantes y n√≠tidos en las superficies pulidas, simulando el comportamiento de materiales como los metales.", "correct": false },
                    { "text": "Produce un sombreado suave que define el volumen de los objetos, haciendo que las caras orientadas hacia la luz se vean m√°s claras que las dem√°s.", "correct": false },
                    { "text": "Genera halos y destellos alrededor de las fuentes de luz m√°s intensas, simulando efectos atmosf√©ricos como el resplandor o la niebla.", "correct": false }
                ]
            },
            {
                "question": "¬øQu√© efecto visual a√±ade la luz difusa?",
                "answers": [
                    { "text": "Este tipo de iluminaci√≥n simula la luz que rebota en el entorno, rellenando las √°reas en sombra con un color suave y evitando el negro absoluto.", "correct": false },
                    { "text": "La luz difusa crea el efecto de sombreado en las superficies seg√∫n el √°ngulo de la luz. Las caras perpendiculares a la luz se ven m√°s claras y las paralelas m√°s oscuras, dando volumen al objeto.", "correct": true },
                    { "text": "A√±ade reflejos especulares muy concentrados en las superficies, lo que simula el brillo caracter√≠stico de los materiales pulidos o h√∫medos.", "correct": false },
                    { "text": "Es responsable de la transparencia y la refracci√≥n, calculando c√≥mo la luz atraviesa los materiales y desv√≠a su trayectoria, como en el vidrio o el agua.", "correct": false }
                ]
            },
            {
                "question": "¬øQu√© efecto visual a√±ade la luz especular?",
                "answers": [
                    { "text": "La luz especular crea brillos o reflejos puntuales en las superficies, simulando materiales brillantes o pulidos. Se ve m√°s intenso cuando el √°ngulo de reflexi√≥n coincide con la direcci√≥n de la c√°mara.", "correct": true },
                    { "text": "Este componente lum√≠nico proporciona una iluminaci√≥n constante a toda la escena, asegurando que ninguna parte quede completamente oscura.", "correct": false },
                    { "text": "Crea el sombreado principal de los objetos, haciendo que las caras que apuntan hacia la fuente de luz se vean m√°s iluminadas y con volumen.", "correct": false },
                    { "text": "Es la responsable de proyectar las sombras de los objetos sobre otras superficies, calculando las √°reas que est√°n ocluidas de la luz.", "correct": false }
                ]
            },
            {
                "question": "¬øC√≥mo obtenemos una escena con sombras m√°s oscuras (o menos suaves)?",
                "answers": [
                    { "text": "Para obtener sombras menos suaves, en el m√©todo calculateShadow del Compute Shader reducimos el porcentaje de luz que se devuelve cuando el rayo hace hit (est√° en sombra). Valores m√°s bajos generan sombras m√°s oscuras.", "correct": true },
                    { "text": "Se logra aumentando la intensidad del componente de luz ambiental en el modelo de iluminaci√≥n, lo que rellena las √°reas ocluidas con m√°s brillo y las hace menos intensas.", "correct": false },
                    { "text": "Para conseguir un efecto m√°s marcado, se debe incrementar el exponente especular en el c√°lculo de Blinn-Phong, concentrando el brillo y oscureciendo el resto de la superficie.", "correct": false },
                    { "text": "Se consigue al disminuir la distancia del `far plane` de la c√°mara, lo que comprime el rango de profundidad y provoca que el `depth buffer` tenga menos precisi√≥n en las zonas lejanas.", "correct": false }
                ]
            }
        ];

        const questionTextElement = document.getElementById('question-text');
        const answerButtonsElement = document.getElementById('answer-buttons');
        const nextButton = document.getElementById('next-btn');
        const questionCounterElement = document.getElementById('question-counter');
        const scoreElement = document.getElementById('score');

        const quizArea = document.getElementById('quiz-area');
        const resultsContainer = document.getElementById('results-container');
        const resultsText = document.getElementById('results-text');
        const playAgainBtn = document.getElementById('play-again-btn');

        let shuffledQuestions, currentQuestionIndex;
        let score = 0;

        function startQuiz() {
            score = 0;
            shuffledQuestions = questions.sort(() => Math.random() - .5);
            currentQuestionIndex = 0;
            quizArea.style.display = 'block';
            resultsContainer.style.display = 'none';
            nextButton.style.display = 'none';
            nextButton.innerHTML = "Siguiente Pregunta ‚Üí";
            showQuestion();
        }

        function showQuestion() {
            resetState();
            let currentQuestion = shuffledQuestions[currentQuestionIndex];
            let questionNo = currentQuestionIndex + 1;
            questionTextElement.innerText = currentQuestion.question;
            questionCounterElement.innerText = `Pregunta ${questionNo} de ${shuffledQuestions.length}`;
            scoreElement.innerText = `Puntaje: ${score}`;

            currentQuestion.answers.forEach(answer => {
                const button = document.createElement('button');
                button.innerText = answer.text;
                button.classList.add('btn');
                answerButtonsElement.appendChild(button);
                if (answer.correct) {
                    button.dataset.correct = answer.correct;
                }
                button.addEventListener('click', selectAnswer);
            });
        }

        function resetState() {
            nextButton.style.display = 'none';
            while (answerButtonsElement.firstChild) {
                answerButtonsElement.removeChild(answerButtonsElement.firstChild);
            }
        }

        function selectAnswer(e) {
            const selectedBtn = e.target;
            const isCorrect = selectedBtn.dataset.correct === "true";

            if (isCorrect) {
                selectedBtn.classList.add('correct');
                score++;
                scoreElement.innerText = `Puntaje: ${score}`;
            } else {
                selectedBtn.classList.add('incorrect');
            }

            Array.from(answerButtonsElement.children).forEach(button => {
                if (button.dataset.correct === "true") {
                    button.classList.add('correct');
                }
                button.disabled = true;
            });

            if (shuffledQuestions.length > currentQuestionIndex + 1) {
                 nextButton.style.display = 'block';
            } else {
                nextButton.innerHTML = "Ver Resultados";
                nextButton.style.display = 'block';
            }
        }

        function handleNextButton() {
            currentQuestionIndex++;
            if (currentQuestionIndex < shuffledQuestions.length) {
                showQuestion();
            } else {
                showResults();
            }
        }
        
        function showResults(){
             quizArea.style.display = 'none';
             resultsContainer.style.display = 'block';
             let finalMessage = `¬°Juego Terminado! Obtuviste ${score} de ${shuffledQuestions.length} respuestas correctas.`;
             if(score / shuffledQuestions.length > 0.7) {
                 finalMessage += " ¬°Excelente trabajo! üöÄ"
             } else {
                 finalMessage += " ¬°Sigue practicando! üí™"
             }
             resultsText.innerText = finalMessage;
        }


        nextButton.addEventListener('click', () => {
            if(currentQuestionIndex < shuffledQuestions.length){
                handleNextButton();
            }
        });
        
        playAgainBtn.addEventListener('click', startQuiz);

        startQuiz();
    </script>
</body>
</html>